# Python, ООП

## Magic или dunder методы
Магическими методы называют методы, имена которых начинаются и заканчиваются двойным подчеркиванием. 
Магические они потому, что почти никогда не вызываются явно. 
Их вызывают встроенные функции или синтаксические конструкции.

### Методы для инициализации и конструктора
|   Метод    |               Аргументы               |        Описание         |
|:----------:|:-------------------------------------:|:-----------------------:|
| `__init__` |             `cls` `other`             |  Инициализация объекта  |
| `__new__`  |            `self` `other`             | Создание нового объекта |
| `__del__`  |                `self`                 |    Удаление объекта     |

#### Разница между `__new__` и `__init__`
Основное различие между этими двумя методами состоит в том, что `__new__` обрабатывает создание объекта, 
а `__init__` обрабатывает его инициализацию.

`__new__` вызывается автоматически при вызове имени класса (при создании экземпляра), 
тогда как `__init__` вызывается каждый раз, когда экземпляр класса возвращается `__new__`, 
передавая возвращаемый экземпляр в `__init__` в качестве параметра self, 
поэтому даже если вы сохранили экземпляр где-нибудь глобально/статически и возвращали его каждый раз из `__new__`, 
для него все-равно будет каждый раз вызываться `__init__`.



### Унарные операторы и функции
|    Метод     | Аргументы  |                         Описание                          |
|:------------:|:----------:|:---------------------------------------------------------:|
|  `__pos__`   |   `self`   |            Вызывается при использовании `+obj`            |
|  `__neg__`   |   `self`   |            Вызывается при использовании `-obj`            |
|  `__abs__`   |   `self`   |  Вызывается при использовании встроенной функции `abs()`  |
| `__invert__` |   `self`   |    Вызывается при использовании оператора инверсии `~`    |
| `__round__`  | `self` `n` | Вызывается при использовании встроенной функции `round()` |
| `__floor__`  |   `self`   |    Вызывается при использовании функции `math.floor()`    |
|  `__ceil__`  |   `self`   |    Вызывается при использовании функции `math.ceil()`     |
| `__trunc__`  |   `self`   |    Вызывается при использовании функции `math.trunc()`    |

### Расширенное присвоение
|      Метод      |   Аргументы    |                              Описание                              |
|:---------------:|:--------------:|:------------------------------------------------------------------:|
|   `__iadd__`    | `self` `other` |         Вызывается при суммировании с присвоением `a += b`         |
|   `__isub__`    | `self` `other` |          Вызывается при вычитании с присвоением `a -= b`           |
|   `__imul__`    | `self` `other` |          Вызывается при умножении с присвоением `a *= b`           |
| `__ifloordiv__` | `self` `other` |   Вызывается при целочисленном делении с присвоением  `a //= b`    |
|   `__idiv__`    | `self` `other` |           Вызывается при делении с присвоением `a /= b`            |
| `__itruediv__`  | `self` `other` |           Вызывается при делении с присвоением `a /= b`            |
|   `__imod__`    | `self` `other` |      Вызывается при делении по модулю с присвоением `a %= b`       |
|   `__ipow__`    | `self` `other` |    Вызывается при возведении в степень с присвоением `a **= b`     |
|  `__ilshift__`  | `self` `other` |   Вызывается при побитовом сдвиге влево с присвоением `a <<= b`    |
|  `__irshift__`  | `self` `other` |   Вызывается при побитовом сдвиге вправо с присвоением `a <<= b`   |
|   `__iand__`    | `self` `other` |        Вызывается при побитовом AND с присвоением `a &= b`         |
|    `__ior__`    | `self` `other` | Вызывается при побитовом OR с присвоением <code>a &#124;= b</code> |
|   `__ixor__`    | `self` `other` |        Вызывается при побитовом XOR с присвоением `a ^= b`         |

### Методы преобразования типов
|     Метод     | Аргументы |                                          Описание                                           |
|:-------------:|:---------:|:-------------------------------------------------------------------------------------------:|
|   `__int__`   |  `self`   |        Вызывается при использовании метода `int()` для преобразования к целому числу        |
|  `__float__`  |  `self`   | Вызывается при использовании метода `float()` для преобразования к числу с плавающей точкой |
| `__complex__` |  `self`   |   Вызывается при использовании метода `complex()` для преобразования к комплексному числу   |
|   `__oct__`   |  `self`   |    Вызывается при использовании метода `oct()` для преобразования к восьмеричному числу     |
|   `__hex__`   |  `self`   |  Вызывается при использовании метода `hex()` для преобразования к шестнадцатеричному числу  |
|  `__index__`  |  `self`   |  Вызывается для преобразования к целому числу когда объект используется в выражении среза   |
|  `__trunc__`  |  `self`   |                     Вызывается при использовании метода `math.trunc()`                      |

### Строковые методы
|     Метод     |     Аргументы      |                       Описание                        |
|:-------------:|:------------------:|:-----------------------------------------------------:|
|   `__str__`   |       `self`       |      Вызывается при использовании метода `str()`      |
|  `__repr__`   |       `self`       |     Вызывается при использовании метода `repr()`      |
| `__unicode__` |       `self`       |    Вызывается при использовании метода `unicode()`    |
| `__format__`  | `self` `formatstr` |  Вызывается при использовании метода `str.format()`   |
|  `__hash__`   |       `self`       |     Вызывается при использовании метода `hash()`      |
| `__nonzero__` |       `self`       |     Вызывается при использовании метода `bool()`      |
|   `__dir__`   |       `self`       |      Вызывается при использовании метода `dir()`      |
| `__sizeof__`  |       `self`       | Вызывается при использовании метода `sys.getsizeof()` |

### Методы атрибутов
|     Метод     |       Аргументы       |                 Описание                  |
|:-------------:|:---------------------:|:-----------------------------------------:|
| `__getattr__` |     `self` `name`     | Вызывается для получения атрибута класса  |
| `__setattr__` | `self` `name` `value` | Вызывается для присвоения атрибута классу |
| `__delattr__` |     `self` `name`     |  Вызывается для удаления атрибута класса  |

### Методы математических операторов
|     Метод      |       Аргументы       |                  Описание                   |
|:--------------:|:---------------------:|:-------------------------------------------:|
|   `__add__`    |        `other`        | Вызывается при использовании оператора `+`  |
|   `__sub__`    |        `other`        | Вызывается при использовании оператора `-`  |
|   `__mul__`    |        `other`        | Вызывается при использовании оператора `*`  |
| `__floordiv__` |        `other`        | Вызывается при использовании оператора `//` |
| `__truediv__`  |        `other`        | Вызывается при использовании оператора `/`  |
|   `__div__`    |        `other`        | Вызывается при использовании оператора `/`  |
|   `__mod__`    |        `other`        | Вызывается при использовании оператора `%`  |
|   `__pow__`    | `other` `modulo=None` | Вызывается при использовании оператора `**` |
|    `__lt__`    |        `other`        | Вызывается при использовании оператора `<`  |
|    `__le__`    |        `other`        | Вызывается при использовании оператора `<=` |
|    `__eq__`    |        `other`        | Вызывается при использовании оператора `==` |
|    `__ne__`    |        `other`        | Вызывается при использовании оператора `!=` |
|    `__gt__`    |        `other`        | Вызывается при использовании оператора `>`  |
|    `__ge__`    |        `other`        | Вызывается при использовании оператора `>=` |

## MRO и наследование
**MRO (Method Resolution Order)** – это порядок разрешения методов в Python

Узнать порядок наследования можно с помощью метода `.mro()`:
```python
class O: ...
class A(O): ...
class B(O): ...
class C(O): ...
class D(O): ...
class E(O): ...
class K1(A, B, C): ...
class K2(B, D): ...
class K3(C, D, E): ...
class Z(K1, K2, K3): ...


print(*[x.__name__ for x in Z.mro()], sep=' -> ')  # Z -> K1 -> A -> K2 -> B -> K3 -> C -> D -> E -> O -> object
```

### Функция `super`
Функция `super()`, возвращает объект-посредник, который делегирует вызовы метода родительскому или родственному классу, 
указанного `type` типа. Это полезно для доступа к унаследованным методам, которые были переопределены в классе.

Например:
```python
class A:
    def some_method(self):
        print('some_method A')


class B(A):
    def some_method(self):
        super().some_method()
        print('some_method B')


x = B()
x.some_method()
```
Выводит:
```
some_method A
some_method B
```

## Миксины (Mixin)
**Mixin классы** - это концепция в программировании, в которой класс предоставляет функциональные возможности, 
но не предназначен для самостоятельного использования. 

Основная цель миксинов - предоставить какие-то дополнительные методы.

Пример использования миксина:
```python
class Radio: ...
class Vehicle: ...

class RadioMixin:
    def __init__(self):
        self.radio = Radio()
        
    def play_radio(self, station):
        print(f'Playing radio on station {station}')

class Car(Vehicle, RadioMixin): ...
class Bus(Vehicle, RadioMixin): ...


Car().play_radio('101.2')  # Playing radio on station 101.2
Bus().play_radio('103.5')  # Playing radio on station 103.5
```

## property
Функция `property()` используется для определения свойств в классах.

Метод `property()` принимает на вход методы `get`, `set` и `delete`, и возвращает объекты класса property.

Пример 1:
```python
class Person:
    def __init__(self, name: str):
        self.__name = name

    @property
    def name(self):
        return self.__name


person = Person('Test')
print(person.name)  # Test
person.name = 'New name'  # AttributeError: can't set attribute 'name'
```

Пример 2:
```python
class Person:
    def __init__(self, name: str):
        self.__name = name

    @property
    def name(self):
        return self.__name

    @name.setter
    def name(self, value):
        self.__name = value

    @name.deleter
    def name(self):
        self.__name = 'Deleted name'


person = Person('Test')
print(person.name)  # Test

person.name = 'New name'
print(person.name)  # New name

del person.name
print(person.name)  # Deleted name
```

## Метаклассы
**Метаклассы** – это классы, которые создают классы. 
В Python, классы сами являются объектами, и метаклассы отвечают за их создание. 
Они определяют правила и поведение, которыми должны обладать классы, создаваемые с их помощью.

### Как работают
* Перехватить создание класса
* Изменить класс
* Вернуть модифицированный класс

### Зачем использовать
Основное применение метаклассов это создание API. Типичный пример — Django ORM.

Она позволяет написать что-то в таком духе:

```python
class Person(models.Model):
    name = models.CharField(max_length=30)
    age = models.IntegerField()
```

Однако если вы выполните следующий код:
```python
guy = Person(name='bob', age='35')
print(guy.age)
```
Вы получите не `IntegerField`, а `int`, причём значение может быть получено прямо из базы данных.

Это возможно, потому что `models.Model` определяет `__metaclass__`, который сотворит некую магию и превратит класс `Person`, 
который мы только что определили простым выражением в сложную привязку к базе данных.

Django делает что-то сложное выглядящее простым, выставляя наружу простой API и используя метаклассы, 
воссоздающие код из API и незаметно делающие всю работу.

## Паттерны проектирования
В разработке программного обеспечения паттерн – это общее, многократно используемое решение проблемы, 
которая часто встречается внутри конкретной ситуации. Это похоже на готовые чертежи, которые можно 
использовать для решения проблемы в вашем коде.

Вот некоторые паттерны:
* Декоратор
* Итератор
* 